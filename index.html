<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS ART STUDIO DELUXE ¬∑ FIREBASE</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <style>
        :root {
            --tetris-cyan: #00f0f0;
            --tetris-blue: #0000f0;
            --tetris-orange: #f0a000;
            --tetris-yellow: #f0f000;
            --tetris-green: #00f000;
            --tetris-purple: #a000f0;
            --tetris-red: #f00000;
            --bg-dark: #0a0a1f;
            --bg-panel: rgba(20, 20, 35, 0.95);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            width: 100vw; height: 100vh;
            background: linear-gradient(135deg, #0a0a1f 0%, #1a1a3a 50%, #0a0a1f 100%);
            font-family: 'Rajdhani', sans-serif;
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-image 0.3s ease;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .floating-blocks { position: fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:-1; opacity:0.1; }
        .floating-block { position: absolute; width:60px; height:60px; background:var(--tetris-cyan); opacity:0.3; transform:rotate(45deg); animation:float 20s infinite linear; }
        @keyframes float { 0% { transform: translateY(-100px) rotate(0deg); } 100% { transform: translateY(100vh) rotate(360deg); } }

        #loading-screen { position:fixed; top:0; left:0; width:100%; height:100%; background:#0a0a1f; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:10000; transition:opacity 0.5s; }
        .tetris-loader { font-family:'Press Start 2P'; font-size:32px; color:var(--tetris-cyan); text-shadow:0 0 20px var(--tetris-cyan); margin-bottom:20px; }
        .loading-bar { width:300px; height:20px; border:2px solid var(--tetris-cyan); }
        .loading-progress { width:0%; height:100%; background:linear-gradient(90deg, var(--tetris-cyan), var(--tetris-purple)); animation:load 2s forwards; }
        @keyframes load { to { width:100%; } }

        /* login screen */
        #login-screen { position:fixed; top:0; left:0; width:100%; height:100%; background:linear-gradient(135deg,#0a0a1f,#1a1a3a); display:flex; justify-content:center; align-items:center; z-index:1000; transition:transform 0.8s cubic-bezier(0.68,-0.55,0.265,1.55); }
        #login-screen.hidden { transform:scale(0); pointer-events:none; }
        .login-container { background:var(--bg-panel); padding:40px; border:4px solid var(--tetris-cyan); box-shadow:0 0 20px var(--tetris-cyan),0 0 40px var(--tetris-purple); text-align:center; width:400px; backdrop-filter:blur(10px); }
        .login-container::before { content:'TETRIS'; position:absolute; top:-25px; left:50%; transform:translateX(-50%); background:linear-gradient(90deg,var(--tetris-cyan),var(--tetris-purple)); color:black; padding:5px 20px; font-family:'Press Start 2P'; font-size:14px; }
        .login-title { font-family:'Press Start 2P'; font-size:24px; margin:30px 0 40px; text-shadow:3px 3px var(--tetris-purple),6px 6px var(--tetris-cyan); }

        #register-modal, #bg-preview-modal, #profile-modal, #save-design-modal, #public-gallery-modal, #tetris-game-modal { 
            position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; justify-content:center; align-items:center; z-index:2000; opacity:0; pointer-events:none; transition:opacity 0.3s; backdrop-filter:blur(5px); 
        }
        #register-modal.active, #bg-preview-modal.active, #profile-modal.active, #save-design-modal.active, #public-gallery-modal.active, #tetris-game-modal.active { opacity:1; pointer-events:all; }
        .modal-content, .preview-container { background:var(--bg-panel); padding:30px; border:4px solid var(--tetris-green); box-shadow:0 0 30px var(--tetris-green); max-width:90vw; max-height:90vh; overflow:auto; }
        .close-modal { position:absolute; top:10px; right:15px; color:#888; font-size:24px; cursor:pointer; }
        .close-modal:hover { color:var(--tetris-red); }

        /* Tetris Game Styles */
        #tetris-game-container {
            display: flex;
            gap: 30px;
            padding: 20px;
            justify-content: center;
            align-items: flex-start;
            position: relative;
        }
        .game-board-container {
            position: relative;
            display: inline-block;
        }
        #game-canvas {
            border: 4px solid var(--tetris-cyan);
            background: #000;
            box-shadow: 0 0 30px var(--tetris-cyan);
            display: block;
        }
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2100;
            border: 4px solid var(--tetris-red);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .game-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .game-over-title {
            color: var(--tetris-red);
            font-family: 'Press Start 2P';
            font-size: 24px;
            margin: 20px 0;
            text-shadow: 0 0 20px var(--tetris-red);
        }
        .final-score {
            font-size: 18px;
            margin: 20px 0;
            color: var(--tetris-yellow);
            text-align: center;
        }
        .final-score span {
            color: var(--tetris-cyan);
            font-size: 32px;
            display: block;
            margin-top: 10px;
        }
        .game-overlay .game-btn {
            width: 150px;
            margin: 10px auto;
        }
        .game-info {
            width: 200px;
            padding: 20px;
            background: rgba(0,0,0,0.6);
            border: 2px solid var(--tetris-cyan);
        }
        .game-info h3 {
            color: var(--tetris-yellow);
            font-family: 'Press Start 2P';
            font-size: 14px;
            margin-bottom: 20px;
        }
        .game-stats {
            margin: 20px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
        }
        .game-stats div {
            margin: 10px 0;
            color: var(--tetris-cyan);
        }
        .next-piece {
            margin: 20px 0;
            text-align: center;
        }
        #next-canvas {
            border: 2px solid var(--tetris-cyan);
            background: #000;
            margin-top: 10px;
        }
        .game-controls {
            margin-top: 20px;
        }
        .game-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border: 2px solid var(--tetris-cyan);
            color: white;
            cursor: pointer;
            font-family: 'Press Start 2P';
            font-size: 10px;
        }
        .game-btn:hover {
            background: var(--tetris-cyan);
            color: black;
        }

        /* Gallery Styles */
        .gallery-container { display:grid; grid-template-columns:repeat(auto-fill, minmax(200px,1fr)); gap:15px; margin-top:20px; max-height:60vh; overflow-y:auto; padding:10px; }
        .gallery-item { background:rgba(0,0,0,0.6); border:2px solid var(--tetris-cyan); padding:10px; cursor:pointer; transition:0.2s; position:relative; }
        .gallery-item:hover { border-color:var(--tetris-yellow); transform:scale(1.02); }
        .gallery-item canvas { width:100%; height:auto; border:1px solid #333; background:#0a0a1f; }
        .gallery-stats { font-size:11px; margin-top:5px; color:var(--tetris-cyan); display:flex; flex-direction:column; gap:3px; }
        .gallery-username { color:var(--tetris-yellow); font-weight:bold; }
        .gallery-name { color:white; font-size:12px; margin-top:5px; padding:2px; background:rgba(0,240,240,0.2); text-align:center; }
        .gallery-privacy { position:absolute; top:5px; right:5px; padding:2px 6px; font-size:10px; border-radius:3px; }
        .privacy-public { background:var(--tetris-green); color:black; }
        .privacy-private { background:var(--tetris-red); color:white; }
        .copy-badge { position:absolute; bottom:5px; right:5px; background:var(--tetris-cyan); color:black; padding:2px 6px; font-size:10px; border-radius:3px; opacity:0; transition:0.2s; }
        .gallery-item:hover .copy-badge { opacity:1; }

        .tab-bar { display:flex; gap:10px; margin-bottom:20px; border-bottom:2px solid #333; padding-bottom:10px; }
        .tab { padding:10px 20px; cursor:pointer; color:#888; border:2px solid transparent; }
        .tab.active { color:var(--tetris-cyan); border-color:var(--tetris-cyan); background:rgba(0,240,240,0.1); }

        /* main app */
        #app-container { display:none; width:95vw; height:90vh; max-width:1800px; background:rgba(20,20,35,0.85); backdrop-filter:blur(10px); border:4px solid var(--tetris-cyan); box-shadow:0 0 20px var(--tetris-cyan),0 0 40px var(--tetris-purple); }
        #app-container.visible { display:flex; animation:slideIn 0.6s; }
        @keyframes slideIn { from { opacity:0; transform:translateY(50px); } to { opacity:1; transform:translateY(0); } }

        #sidebar { width:380px; background:rgba(0,0,0,0.6); backdrop-filter:blur(10px); border-right:4px solid var(--tetris-cyan); padding:20px; display:flex; flex-direction:column; gap:15px; overflow-y:auto; }
        .user-info { background:linear-gradient(135deg, rgba(0,240,240,0.1), rgba(160,0,240,0.1)); padding:15px; border:2px solid var(--tetris-cyan); display:flex; align-items:center; gap:15px; }
        .user-avatar { width:50px; height:50px; background:linear-gradient(135deg,var(--tetris-cyan),var(--tetris-purple)); display:flex; justify-content:center; align-items:center; font-family:'Press Start 2P'; font-size:20px; color:black; }
        .section-title { font-family:'Press Start 2P'; font-size:10px; color:var(--tetris-yellow); margin-bottom:10px; text-shadow:0 0 5px var(--tetris-yellow); }
        .shape-grid, .color-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
        .shape-btn, .color-btn { aspect-ratio:1; background:rgba(255,255,255,0.1); border:2px solid #444; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:0.2s; }
        .shape-btn:hover, .color-btn:hover { border-color:var(--tetris-cyan); box-shadow:0 0 15px var(--tetris-cyan); transform:scale(1.05); }
        .shape-btn.active, .color-btn.active { border-color:var(--tetris-cyan); box-shadow:0 0 15px var(--tetris-cyan); background:rgba(0,240,240,0.2); }
        .color-btn { border:3px solid transparent; box-shadow:0 0 5px currentColor; }

        .privacy-toggle { display:flex; gap:10px; margin:15px 0; padding:10px; background:rgba(0,0,0,0.3); }
        .privacy-option { flex:1; padding:10px; text-align:center; background:rgba(255,255,255,0.1); border:2px solid #444; cursor:pointer; }
        .privacy-option.active { border-color:var(--tetris-cyan); background:rgba(0,240,240,0.2); }
        .privacy-option.public.active { border-color:var(--tetris-green); }
        .privacy-option.private.active { border-color:var(--tetris-red); }

        .custom-color-section { margin-top:10px; padding:10px; background:rgba(0,0,0,0.3); border:1px solid #333; }
        .color-picker-row { display:flex; gap:10px; align-items:center; }
        #custom-color { width:50px; height:50px; border:2px solid var(--tetris-cyan); }
        .hex-input { flex:1; padding:10px; background:rgba(0,0,0,0.5); border:2px solid #333; color:var(--tetris-cyan); font-family:monospace; }

        .block-type-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:8px; margin-top:10px; }
        .block-type-btn { padding:10px; background:rgba(255,255,255,0.05); border:2px solid #444; color:white; cursor:pointer; text-align:center; }
        .block-type-btn.active { border-color:var(--tetris-cyan); background:rgba(0,240,240,0.2); }

        .slider-control { margin:10px 0; }
        .slider-label { display:flex; justify-content:space-between; color:var(--tetris-cyan); font-size:12px; }
        .slider { width:100%; height:8px; background:#333; -webkit-appearance:none; }
        .slider::-webkit-slider-thumb { -webkit-appearance:none; width:20px; height:20px; background:var(--tetris-cyan); border:2px solid white; box-shadow:0 0 10px var(--tetris-cyan); cursor:pointer; }

        .toggle-switch { display:flex; align-items:center; gap:10px; margin:10px 0; }
        .switch { position:relative; display:inline-block; width:60px; height:30px; }
        .switch input { opacity:0; width:0; height:0; }
        .slider-toggle { position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#333; transition:.2s; border-radius:30px; }
        .slider-toggle:before { position:absolute; content:""; height:22px; width:22px; left:4px; bottom:4px; background:white; transition:.2s; border-radius:50%; }
        input:checked + .slider-toggle { background-color:var(--tetris-cyan); }
        input:checked + .slider-toggle:before { transform:translateX(30px); }

        .toolbar { display:flex; flex-direction:column; gap:8px; }
        .tool-btn { padding:12px; background:rgba(255,255,255,0.05); border:2px solid #444; color:white; font-family:'Rajdhani',sans-serif; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:10px; transition:0.2s; }
        .tool-btn:hover { border-color:var(--tetris-cyan); box-shadow:0 0 10px var(--tetris-cyan); }
        .tool-btn.primary { background:linear-gradient(90deg,var(--tetris-cyan),var(--tetris-blue)); border:none; color:black; }
        .tool-btn.success { background:linear-gradient(90deg,var(--tetris-green),#00a000); border:none; color:black; }
        .tool-btn.warning { background:linear-gradient(90deg,var(--tetris-orange),var(--tetris-red)); border:none; color:black; }
        .tool-btn.game { background:linear-gradient(90deg,var(--tetris-purple),var(--tetris-cyan)); border:none; color:black; }

        #canvas-area { flex:1; display:flex; flex-direction:column; position:relative; overflow:hidden; }
        #canvas-header { padding:15px 25px; background:rgba(0,0,0,0.5); border-bottom:2px solid var(--tetris-cyan); display:flex; justify-content:space-between; align-items:center; }
        #canvas-title { font-family:'Press Start 2P'; font-size:14px; color:var(--tetris-cyan); }
        #canvas-stats { display:flex; gap:20px; font-size:12px; }
        
        #canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a1f;
            transition: background-image 0.3s ease;
            overflow: auto;
            padding: 10px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        #art-canvas {
            border: 3px solid var(--tetris-cyan);
            box-shadow: 0 0 30px var(--tetris-cyan), inset 0 0 50px rgba(0,240,240,0.2);
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000000;
        }

        #block-preview { position:fixed; pointer-events:none; z-index:100; display:none; filter:drop-shadow(0 0 10px currentColor); }

        #notification { position:fixed; top:20px; right:20px; padding:15px 25px; background:linear-gradient(90deg,var(--tetris-green),#00a000); color:black; font-weight:bold; z-index:10000; transform:translateX(150%); transition:transform 0.3s; box-shadow:0 0 20px var(--tetris-green); border:2px solid white; }
        #notification.show { transform:translateX(0); }
        #notification.error { background:linear-gradient(90deg,var(--tetris-red),#a00000); color:white; }

        .input-group { margin-bottom:20px; text-align:left; }
        .input-group label { display:block; margin-bottom:8px; color:var(--tetris-cyan); }
        .input-group input, .input-group textarea { width:100%; padding:15px; background:rgba(0,0,0,0.5); border:2px solid #333; border-left:4px solid var(--tetris-cyan); color:white; font-size:16px; }
        .input-group textarea { min-height:80px; resize:vertical; }
        .login-btn { width:100%; padding:18px; background:linear-gradient(90deg,var(--tetris-cyan),var(--tetris-purple)); border:none; color:black; font-family:'Press Start 2P'; font-size:12px; cursor:pointer; }
        .register-link a { color:var(--tetris-yellow); cursor:pointer; }
    </style>
</head>
<body>
    <div class="floating-blocks" id="floating-blocks"></div>

    <div id="loading-screen">
        <div class="tetris-loader">TETRIS</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
        <p style="margin-top:20px; color:#00f0f0;">LOADING SYSTEM...</p>
    </div>

    <!-- LOGIN SCREEN -->
    <div id="login-screen">
        <div class="login-container">
            <div class="login-title">ART STUDIO</div>
            <div class="input-group"><label>EMAIL</label><input type="email" id="login-email" placeholder="Enter email..."></div>
            <div class="input-group"><label>PASSWORD</label><input type="password" id="login-password" placeholder="Enter password..."></div>
            <button class="login-btn" onclick="handleLogin()">LOGIN</button>
            <div class="register-link">New player? <a onclick="showRegisterModal()">Create Account</a></div>
        </div>
    </div>

    <!-- REGISTER MODAL -->
    <div id="register-modal">
        <div class="modal-content"><span class="close-modal" onclick="hideRegisterModal()">&times;</span>
            <div class="login-title">REGISTER</div>
            <div class="input-group"><label>USERNAME</label><input type="text" id="reg-username"></div>
            <div class="input-group"><label>EMAIL</label><input type="email" id="reg-email"></div>
            <div class="input-group"><label>PASSWORD</label><input type="password" id="reg-password"></div>
            <div class="input-group"><label>CONFIRM</label><input type="password" id="reg-confirm"></div>
            <button class="login-btn" onclick="handleRegister()" style="background:linear-gradient(90deg,var(--tetris-green),#00a000);">CREATE ACCOUNT</button>
        </div>
    </div>

    <!-- BG PREVIEW MODAL -->
    <div id="bg-preview-modal">
        <div class="preview-container">
            <canvas id="bg-preview-canvas" style="border:2px solid #444; margin-bottom:20px; max-width:100%;"></canvas>
            <div style="display:flex; gap:10px; justify-content:center;">
                <button class="tool-btn success" onclick="confirmApplyBackground()"><span class="icon">‚úì</span> APPLY AS PAGE BG</button>
                <button class="tool-btn" onclick="hideBackgroundPreview()"><span class="icon">‚úó</span> CANCEL</button>
            </div>
        </div>
    </div>

    <!-- SAVE DESIGN MODAL -->
    <div id="save-design-modal">
        <div class="modal-content" style="width:450px;">
            <span class="close-modal" onclick="hideSaveModal()">&times;</span>
            <div class="login-title" style="font-size:20px;">üíæ SAVE DESIGN</div>
            <div class="input-group">
                <label>DESIGN NAME</label>
                <input type="text" id="design-name" placeholder="Enter design name..." maxlength="50">
            </div>
            <div class="input-group">
                <label>DESCRIPTION (optional)</label>
                <textarea id="design-description" placeholder="Describe your design..."></textarea>
            </div>
            <div class="privacy-toggle">
                <div class="privacy-option public active" onclick="setDesignPrivacy('public')" id="privacy-public">üåç PUBLIC</div>
                <div class="privacy-option private" onclick="setDesignPrivacy('private')" id="privacy-private">üîí PRIVATE</div>
            </div>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button class="tool-btn success" onclick="confirmSaveDesign()"><span class="icon">üíæ</span> SAVE DESIGN</button>
                <button class="tool-btn" onclick="hideSaveModal()">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- PUBLIC GALLERY MODAL -->
    <div id="public-gallery-modal">
        <div class="modal-content" style="width:900px; max-width:95vw;">
            <span class="close-modal" onclick="hidePublicGallery()">&times;</span>
            <div class="login-title" style="font-size:20px;">üåç PUBLIC GALLERY</div>
            
            <div class="tab-bar">
                <div class="tab active" onclick="switchGalleryTab('public')" id="tab-public">PUBLIC DESIGNS</div>
                <div class="tab" onclick="switchGalleryTab('private')" id="tab-private">MY PRIVATE DESIGNS</div>
                <div class="tab" onclick="switchGalleryTab('all')" id="tab-all">ALL MY DESIGNS</div>
            </div>

            <div style="display:flex; gap:20px; margin-bottom:20px; background:rgba(0,0,0,0.5); padding:15px;">
                <div><span style="color:var(--tetris-cyan);">TOTAL BLOCKS:</span> <strong id="gallery-total-blocks">0</strong></div>
                <div><span style="color:var(--tetris-yellow);">DESIGNS:</span> <strong id="gallery-total-designs">0</strong></div>
            </div>

            <div id="public-gallery-container" class="gallery-container"></div>

            <div style="display:flex; gap:10px; justify-content:center; margin-top:15px;">
                <button class="tool-btn" onclick="hidePublicGallery()">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- TETRIS GAME MODAL -->
    <div id="tetris-game-modal">
        <div class="modal-content" style="width:800px;">
            <span class="close-modal" onclick="hideTetrisGame()">&times;</span>
            <div class="login-title" style="font-size:20px;">üéÆ TETRIS CLASSIC</div>
            
            <div id="tetris-game-container">
                <div class="game-board-container">
                    <canvas id="game-canvas" width="300" height="600"></canvas>
                    <div class="game-overlay" id="game-overlay">
                        <div class="game-over-title">GAME OVER</div>
                        <div class="final-score">
                            FINAL SCORE<br>
                            <span id="final-score-value">0</span>
                        </div>
                        <div class="final-score" style="font-size:14px;">
                            LINES CLEARED<br>
                            <span id="final-lines-value" style="font-size:24px;">0</span>
                        </div>
                        <button class="game-btn" onclick="restartTetrisGame()">PLAY AGAIN</button>
                        <button class="game-btn" onclick="hideTetrisGameOverlay()">CLOSE</button>
                    </div>
                </div>
                
                <div class="game-info">
                    <h3>TETRIS</h3>
                    
                    <div class="game-stats">
                        <div>SCORE: <span id="game-score">0</span></div>
                        <div>LINES: <span id="game-lines">0</span></div>
                        <div>LEVEL: <span id="game-level">1</span></div>
                    </div>

                    <div class="next-piece">
                        <div>NEXT:</div>
                        <canvas id="next-canvas" width="120" height="120"></canvas>
                    </div>

                    <div class="toggle-switch" style="justify-content: center;">
                        <span>üéµ MUSIC</span>
                        <label class="switch">
                            <input type="checkbox" id="game-music-toggle" checked>
                            <span class="slider-toggle"></span>
                        </label>
                    </div>

                    <div class="game-controls">
                        <button class="game-btn" onclick="restartTetrisGame()">NEW GAME</button>
                        <button class="game-btn" onclick="pauseTetrisGame()">PAUSE</button>
                        <div style="font-size:8px; margin-top:10px; color:#888;">
                            ‚Üê ‚Üí : MOVE<br>
                            ‚Üë : ROTATE<br>
                            ‚Üì : SOFT DROP<br>
                            SPACE : HARD DROP<br>
                            P : PAUSE
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PROFILE MODAL (Local Storage Backup) -->
    <div id="profile-modal">
        <div class="modal-content" style="width:800px; max-width:90vw;">
            <span class="close-modal" onclick="hideProfileModal()">&times;</span>
            <div class="login-title" style="font-size:20px;">üìÅ LOCAL BACKUP</div>
            <div style="display:flex; gap:20px; margin-bottom:20px; background:rgba(0,0,0,0.5); padding:15px;">
                <div><span style="color:var(--tetris-cyan);">LOCAL DESIGNS:</span> <strong id="local-designs-count">0</strong></div>
            </div>
            <div id="local-gallery-container" class="gallery-container"></div>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:15px;">
                <button class="tool-btn" onclick="hideProfileModal()">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="app-container">
        <div id="sidebar">
            <div class="user-info">
                <div class="user-avatar" id="user-avatar">T</div>
                <div><h3 id="display-username">PLAYER</h3><p style="color:var(--tetris-cyan);">LEVEL <span id="user-level">1</span></p></div>
            </div>
            <div><div class="section-title">üî∑ BLOCKS</div><div class="shape-grid" id="shape-selector"></div></div>
            <div><div class="section-title">üé® COLORS</div><div class="color-grid" id="color-picker"></div>
                <div class="custom-color-section"><div class="color-picker-row"><input type="color" id="custom-color" value="#00f0f0"><input type="text" class="hex-input" id="custom-hex" value="#00f0f0"></div><button class="tool-btn" onclick="applyCustomColor()" style="width:100%;">USE CUSTOM COLOR</button></div>
            </div>
            <div><div class="section-title">‚ú® BLOCK STYLE</div><div class="block-type-grid"><button class="block-type-btn active" onclick="setBlockType('solid')">SOLID</button><button class="block-type-btn" onclick="setBlockType('outline')">OUTLINE</button><button class="block-type-btn" onclick="setBlockType('glow')">GLOW</button><button class="block-type-btn" onclick="setBlockType('3d')">3D</button></div></div>
            <div><div class="section-title">‚ö° EFFECTS</div>
                <div class="toggle-switch"><span>üîä SOUND</span><label class="switch"><input type="checkbox" id="sound-toggle" checked><span class="slider-toggle"></span></label></div>
                <div class="slider-control"><div class="slider-label"><span>üîÆ OPACITY</span><span id="opacity-value">100%</span></div><input type="range" id="opacity-slider" class="slider" min="0.1" max="1" step="0.1" value="1"></div>
                <div class="slider-control"><div class="slider-label"><span>üîç CANVAS SCALE</span><span id="scale-value">100%</span></div><input type="range" id="scale-slider" class="slider" min="0.5" max="1.8" step="0.1" value="1"></div>
            </div>
            <div><div class="section-title">üõ†Ô∏è TOOLS</div><div class="toolbar"><button class="tool-btn" onclick="rotateShape()"><span class="icon">‚Üª</span> ROTATE (R)</button><button class="tool-btn" onclick="undoAction()"><span class="icon">‚Ü©</span> UNDO</button><button class="tool-btn" onclick="clearCanvas()"><span class="icon">üóë</span> CLEAR</button></div></div>
            <div><div class="section-title">üíæ ACTIONS</div><div class="toolbar">
                <button class="tool-btn game" onclick="showTetrisGame()"><span class="icon">üéÆ</span> PLAY TETRIS</button>
                <button class="tool-btn success" onclick="previewBackground()"><span class="icon">üëÅ</span> PREVIEW PAGE BG</button>
                <button class="tool-btn" onclick="setCanvasBackground()"><span class="icon">üñºÔ∏è</span> SET CANVAS BG</button>
                <button class="tool-btn primary" onclick="showSaveModal()"><span class="icon">üíæ</span> SAVE DESIGN</button>
                <button class="tool-btn warning" onclick="showPublicGallery()"><span class="icon">üåç</span> PUBLIC GALLERY</button>
                <button class="tool-btn" onclick="showLocalDesigns()"><span class="icon">üìÅ</span> LOCAL BACKUP</button>
                <button class="tool-btn" onclick="downloadBackground()"><span class="icon">‚¨á</span> DOWNLOAD PNG</button>
                <button class="tool-btn" onclick="logout()"><span class="icon">üö™</span> LOGOUT</button>
            </div></div>
            <div style="background:rgba(0,0,0,0.3); padding:10px; font-size:11px;">
                <div style="display:flex; justify-content:space-between;"><span>Left Click</span><span style="background:#333; padding:2px 6px;">Place</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Right Click</span><span style="background:#333; padding:2px 6px;">Delete</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Scroll</span><span style="background:#333; padding:2px 6px;">Rotate</span></div>
            </div>
        </div>
        <div id="canvas-area">
            <div id="canvas-header"><div id="canvas-title">üéÆ TETRIS CANVAS</div><div id="canvas-stats"><span>BLOCKS: <strong id="block-count">0</strong></span><span>GRID: 32x18</span></div></div>
            <div id="canvas-wrapper"><canvas id="art-canvas"></canvas></div>
        </div>
    </div>

    <canvas id="block-preview"></canvas>
    <div id="notification"></div>

    <script>
        (function() {
            const firebaseConfig = {
                apiKey: "AIzaSyCKhN9jgbQVrUSbxMeD-1y4Ve3BV5-omA4",
                authDomain: "tetris-art-studio.firebaseapp.com",
                projectId: "tetris-art-studio",
                storageBucket: "tetris-art-studio.firebasestorage.app",
                messagingSenderId: "793493379153",
                appId: "1:793493379153:web:6c608c02b687d3e72ac070",
                measurementId: "G-WGY100LTG7"
            };
            firebase.initializeApp(firebaseConfig);
            const auth = firebase.auth();
            const db = firebase.firestore();

            // Audio System for Art Studio
            const AudioSys = {
                ctx: null, enabled: true,
                init() { 
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                    } catch(e) {
                        console.warn('Audio not supported');
                    }
                },
                play(type) {
                    if (!this.enabled) return;
                    if (!this.ctx) this.init();
                    if (!this.ctx) return;
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    
                    try {
                        const osc = this.ctx.createOscillator(); 
                        const gain = this.ctx.createGain();
                        osc.connect(gain); 
                        gain.connect(this.ctx.destination);
                        const now = this.ctx.currentTime;
                        
                        switch(type) {
                            case 'place': 
                                osc.type='square'; 
                                osc.frequency.setValueAtTime(200,now); 
                                osc.frequency.exponentialRampToValueAtTime(400,now+0.1); 
                                gain.gain.setValueAtTime(0.15,now); 
                                gain.gain.exponentialRampToValueAtTime(0.01,now+0.15); 
                                osc.start(now); 
                                osc.stop(now+0.15); 
                                break;
                            case 'rotate': 
                                osc.type='sine'; 
                                osc.frequency.setValueAtTime(300,now); 
                                osc.frequency.linearRampToValueAtTime(500,now+0.05); 
                                gain.gain.setValueAtTime(0.1,now); 
                                gain.gain.exponentialRampToValueAtTime(0.01,now+0.05); 
                                osc.start(now); 
                                osc.stop(now+0.05); 
                                break;
                            case 'delete': 
                                osc.type='sawtooth'; 
                                osc.frequency.setValueAtTime(150,now); 
                                osc.frequency.exponentialRampToValueAtTime(50,now+0.1); 
                                gain.gain.setValueAtTime(0.1,now); 
                                gain.gain.exponentialRampToValueAtTime(0.01,now+0.1); 
                                osc.start(now); 
                                osc.stop(now+0.1); 
                                break;
                            case 'login': 
                                [523,659,784,1047].forEach((freq,i)=>{ 
                                    let o=this.ctx.createOscillator(), g=this.ctx.createGain(); 
                                    o.connect(g); 
                                    g.connect(this.ctx.destination); 
                                    o.type='square'; 
                                    o.frequency.value=freq; 
                                    g.gain.setValueAtTime(0.1,now+i*0.1); 
                                    g.gain.exponentialRampToValueAtTime(0.01,now+i*0.1+0.1); 
                                    o.start(now+i*0.1); 
                                    o.stop(now+i*0.1+0.1); 
                                }); 
                                break;
                            case 'error': 
                                osc.type='sawtooth'; 
                                osc.frequency.setValueAtTime(100,now); 
                                osc.frequency.linearRampToValueAtTime(50,now+0.2); 
                                gain.gain.setValueAtTime(0.2,now); 
                                gain.gain.exponentialRampToValueAtTime(0.01,now+0.2); 
                                osc.start(now); 
                                osc.stop(now+0.2); 
                                break;
                        }
                    } catch(e) {
                        console.warn('Audio play failed:', e);
                    }
                },
                toggle(enabled) { this.enabled = enabled; }
            };

            // Tetris Game Audio System
            const TetrisAudio = {
                ctx: null, enabled: true, musicSource: null, musicGain: null, isPlaying: false,
                init() { 
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                    } catch(e) {
                        console.warn('Audio not supported');
                    }
                },
                playMusic() {
                    if (!this.enabled || !document.getElementById('game-music-toggle').checked) return;
                    if (!this.ctx) this.init();
                    if (!this.ctx) return;
                    if (this.isPlaying) return;
                    
                    this.isPlaying = true;
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    
                    this.musicGain = this.ctx.createGain();
                    this.musicGain.connect(this.ctx.destination);
                    this.musicGain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    
                    this.playTetrisTheme();
                },
                playTetrisTheme() {
                    const notes = [
                        { note: 659, duration: 0.2 }, // E5
                        { note: 493, duration: 0.1 }, // B4
                        { note: 523, duration: 0.1 }, // C5
                        { note: 587, duration: 0.2 }, // D5
                        { note: 659, duration: 0.3 }, // E5
                        { note: 523, duration: 0.1 }, // C5
                        { note: 587, duration: 0.2 }, // D5
                        { note: 659, duration: 0.3 }, // E5
                        { note: 493, duration: 0.1 }, // B4
                        { note: 523, duration: 0.1 }, // C5
                        { note: 587, duration: 0.2 }, // D5
                        { note: 659, duration: 0.3 }, // E5
                        { note: 523, duration: 0.1 }, // C5
                        { note: 587, duration: 0.2 }, // D5
                        { note: 659, duration: 0.4 }, // E5
                        { note: 784, duration: 0.3 }, // G5
                        { note: 880, duration: 0.2 }, // A5
                        { note: 987, duration: 0.1 }, // B5
                        { note: 1046, duration: 0.4 } // C6
                    ];
                    
                    let time = this.ctx.currentTime;
                    
                    const scheduleNote = (freq, dur) => {
                        if (!this.enabled || !this.isPlaying) return;
                        
                        const osc = this.ctx.createOscillator();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        osc.connect(this.musicGain);
                        
                        osc.start(time);
                        osc.stop(time + dur);
                        time += dur * 0.9;
                    };
                    
                    const playLoop = () => {
                        if (!this.isPlaying || !this.enabled) return;
                        notes.forEach(n => scheduleNote(n.note, n.duration));
                        setTimeout(playLoop, (time - this.ctx.currentTime) * 1000 + 200);
                    };
                    
                    playLoop();
                },
                stopMusic() {
                    this.isPlaying = false;
                },
                toggle(enabled) { 
                    this.enabled = enabled; 
                    if (enabled) {
                        this.playMusic();
                    } else {
                        this.stopMusic();
                    }
                },
                playEffect(type) {
                    if (!this.enabled) return;
                    if (!this.ctx) this.init();
                    if (!this.ctx) return;
                    
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    
                    const now = this.ctx.currentTime;
                    
                    switch(type) {
                        case 'move':
                            osc.frequency.value = 300;
                            gain.gain.setValueAtTime(0.05, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                            osc.start(now);
                            osc.stop(now + 0.05);
                            break;
                        case 'rotate':
                            osc.frequency.value = 400;
                            gain.gain.setValueAtTime(0.05, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                            osc.start(now);
                            osc.stop(now + 0.05);
                            break;
                        case 'drop':
                            osc.frequency.setValueAtTime(200, now);
                            osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                            gain.gain.setValueAtTime(0.1, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            osc.start(now);
                            osc.stop(now + 0.1);
                            break;
                        case 'line':
                            [523, 659, 784].forEach((freq, i) => {
                                const o = this.ctx.createOscillator();
                                const g = this.ctx.createGain();
                                o.connect(g);
                                g.connect(this.ctx.destination);
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.1, now + i * 0.05);
                                g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);
                                o.start(now + i * 0.05);
                                o.stop(now + i * 0.05 + 0.1);
                            });
                            break;
                        case 'gameover':
                            [200, 150, 100, 50].forEach((freq, i) => {
                                const o = this.ctx.createOscillator();
                                const g = this.ctx.createGain();
                                o.connect(g);
                                g.connect(this.ctx.destination);
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.1, now + i * 0.1);
                                g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
                                o.start(now + i * 0.1);
                                o.stop(now + i * 0.1 + 0.2);
                            });
                            break;
                    }
                }
            };

            const CONFIG = {
                TILE_SIZE: 28, GRID_W: 32, GRID_H: 18,
                SHAPES: {
                    'I':{matrix:[[1,1,1,1]],color:'#00f0f0'}, 'J':{matrix:[[1,0,0],[1,1,1]],color:'#0000f0'},
                    'L':{matrix:[[0,0,1],[1,1,1]],color:'#f0a000'}, 'O':{matrix:[[1,1],[1,1]],color:'#f0f000'},
                    'S':{matrix:[[0,1,1],[1,1,0]],color:'#00f000'}, 'T':{matrix:[[0,1,0],[1,1,1]],color:'#a000f0'},
                    'Z':{matrix:[[1,1,0],[0,1,1]],color:'#f00000'}
                },
                PALETTE: ['#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000','#ffffff','#ff00ff','#00ffff','#888888','#333333']
            };

            let State = {
                user: null, placedBlocks: [], history: [], currentShape:'T', currentMatrix:CONFIG.SHAPES.T.matrix,
                currentColor:CONFIG.SHAPES.T.color, blockType:'solid', opacity:1, canvas:null, ctx:null,
                previewCanvas:null, previewCtx:null, scale:1, currentPrivacy: 'public'
            };

            // Tetris Game State
            let TetrisGame = {
                canvas: null, ctx: null, nextCanvas: null, nextCtx: null,
                grid: Array(20).fill().map(() => Array(10).fill(0)),
                score: 0, lines: 0, level: 1,
                piece: null, nextPiece: null, gameInterval: null, gameOver: false, paused: false,
                tetrominos: [
                    { // I
                        matrix: [[1,1,1,1]],
                        color: '#00f0f0'
                    },
                    { // O
                        matrix: [[1,1],[1,1]],
                        color: '#f0f000'
                    },
                    { // T
                        matrix: [[0,1,0],[1,1,1]],
                        color: '#a000f0'
                    },
                    { // S
                        matrix: [[0,1,1],[1,1,0]],
                        color: '#00f000'
                    },
                    { // Z
                        matrix: [[1,1,0],[0,1,1]],
                        color: '#f00000'
                    },
                    { // J
                        matrix: [[1,0,0],[1,1,1]],
                        color: '#0000f0'
                    },
                    { // L
                        matrix: [[0,0,1],[1,1,1]],
                        color: '#f0a000'
                    }
                ]
            };

            // Helper function to serialize blocks for Firestore
            function serializeBlocks(blocks) {
                return blocks.map(block => ({
                    x: block.x,
                    y: block.y,
                    color: block.color,
                    matrixStr: JSON.stringify(block.matrix)
                }));
            }

            // Helper function to deserialize blocks from Firestore
            function deserializeBlocks(blocks) {
                return blocks.map(block => ({
                    x: block.x,
                    y: block.y,
                    color: block.color,
                    matrix: JSON.parse(block.matrixStr)
                }));
            }

            // Privacy setting for new designs
            function setDesignPrivacy(privacy) {
                State.currentPrivacy = privacy;
                document.getElementById('privacy-public').classList.toggle('active', privacy === 'public');
                document.getElementById('privacy-private').classList.toggle('active', privacy === 'private');
            }

            // Save design to Firebase
            async function saveDesignToFirebase(designName, description = '') {
                if (State.placedBlocks.length === 0) {
                    showNotification('No blocks to save!', true);
                    return false;
                }

                if (!State.user) {
                    showNotification('Please login first!', true);
                    return false;
                }

                try {
                    // Create thumbnail
                    let thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = 140;
                    thumbCanvas.height = 80;
                    let thumbCtx = thumbCanvas.getContext('2d');
                    thumbCtx.fillStyle = '#0a0a1f';
                    thumbCtx.fillRect(0, 0, 140, 80);
                    
                    State.placedBlocks.forEach(block => {
                        block.matrix.forEach((row, ri) => {
                            row.forEach((cell, ci) => {
                                if (cell) {
                                    thumbCtx.fillStyle = block.color;
                                    thumbCtx.fillRect(block.x * 2 + ci * 2, block.y * 2 + ri * 2, 2, 2);
                                }
                            });
                        });
                    });
                    
                    let thumbnail = thumbCanvas.toDataURL('image/png');

                    // Prepare design data with serialized blocks
                    let designData = {
                        name: designName,
                        description: description,
                        username: State.user.username,
                        userId: State.user.id,
                        privacy: State.currentPrivacy,
                        blockCount: State.placedBlocks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        blocks: serializeBlocks(State.placedBlocks),
                        thumbnail: thumbnail
                    };

                    // Save to Firestore
                    const docRef = await db.collection('designs').add(designData);
                    console.log('Design saved with ID:', docRef.id);
                    
                    // Also save to local storage as backup
                    saveDesignToLocal(designName, 'backup');
                    
                    showNotification(`Design "${designName}" saved!`);
                    return true;

                } catch (error) {
                    console.error('Save error:', error);
                    showNotification('Failed to save: ' + error.message, true);
                    return false;
                }
            }

            // Load public designs from Firebase
            async function loadPublicDesigns() {
                try {
                    console.log('Loading public designs...');
                    
                    // First, try without orderBy to check if any documents exist
                    const checkSnapshot = await db.collection('designs')
                        .where('privacy', '==', 'public')
                        .limit(1)
                        .get();
                    
                    console.log('Check snapshot empty?', checkSnapshot.empty);
                    
                    if (checkSnapshot.empty) {
                        console.log('No public designs found');
                        return [];
                    }
                    
                    // If documents exist, try with orderBy
                    const snapshot = await db.collection('designs')
                        .where('privacy', '==', 'public')
                        .orderBy('createdAt', 'desc')
                        .limit(50)
                        .get();
                    
                    console.log('Found', snapshot.size, 'public designs');
                    
                    let designs = [];
                    snapshot.forEach(doc => {
                        let data = doc.data();
                        console.log('Design data:', data.name, data.privacy);
                        if (data.blocks) {
                            try {
                                data.blocks = deserializeBlocks(data.blocks);
                            } catch (e) {
                                console.warn('Failed to deserialize blocks:', e);
                                data.blocks = [];
                            }
                        }
                        designs.push({ id: doc.id, ...data });
                    });
                    return designs;
                } catch (error) {
                    console.error('Load error:', error);
                    if (error.code === 'failed-precondition') {
                        showNotification('Please create an index in Firebase Console', true);
                        console.log('Create this index: collection: designs, fields: privacy (ascending), createdAt (descending)');
                    } else {
                        showNotification('Failed to load public designs: ' + error.message, true);
                    }
                    return [];
                }
            }

            // Load user's private designs
            async function loadUserDesigns(privacy = null) {
                if (!State.user) return [];

                try {
                    console.log('Loading user designs for:', State.user.username);
                    
                    let query = db.collection('designs').where('userId', '==', State.user.id);
                    if (privacy) {
                        query = query.where('privacy', '==', privacy);
                    }
                    
                    // Try without orderBy first
                    const checkSnapshot = await query.limit(1).get();
                    
                    if (checkSnapshot.empty) {
                        console.log('No user designs found');
                        return [];
                    }
                    
                    // Then with orderBy
                    query = query.orderBy('createdAt', 'desc').limit(50);
                    const snapshot = await query.get();
                    
                    console.log('Found', snapshot.size, 'user designs');
                    
                    let designs = [];
                    snapshot.forEach(doc => {
                        let data = doc.data();
                        if (data.blocks) {
                            try {
                                data.blocks = deserializeBlocks(data.blocks);
                            } catch (e) {
                                console.warn('Failed to deserialize blocks:', e);
                                data.blocks = [];
                            }
                        }
                        designs.push({ id: doc.id, ...data });
                    });
                    return designs;
                } catch (error) {
                    console.error('Load error:', error);
                    if (error.code === 'failed-precondition') {
                        showNotification('Please create an index in Firebase Console', true);
                    } else {
                        showNotification('Failed to load your designs', true);
                    }
                    return [];
                }
            }

            // Load design into canvas
            function loadDesign(design) {
                if (design.blocks) {
                    State.placedBlocks = design.blocks.map(b => ({
                        x: b.x,
                        y: b.y,
                        color: b.color,
                        matrix: b.matrix.map(row => [...row])
                    }));
                    renderCanvas();
                    showNotification(`Design "${design.name || 'Untitled'}" loaded`);
                    AudioSys.play('rotate');
                }
            }

            // Copy design to current canvas (merge)
            function copyDesignToCanvas(design) {
                if (!design.blocks) return;
                
                let offsetX = 0, offsetY = 0;
                let placed = false;
                
                for (let tryY = 0; tryY < CONFIG.GRID_H && !placed; tryY++) {
                    for (let tryX = 0; tryX < CONFIG.GRID_W && !placed; tryX++) {
                        let canPlace = true;
                        for (let block of design.blocks) {
                            for (let r = 0; r < block.matrix.length; r++) {
                                for (let c = 0; c < block.matrix[r].length; c++) {
                                    if (block.matrix[r][c]) {
                                        let wx = tryX + block.x + c;
                                        let wy = tryY + block.y + r;
                                        if (wx >= CONFIG.GRID_W || wy >= CONFIG.GRID_H) {
                                            canPlace = false;
                                            break;
                                        }
                                        if (State.placedBlocks.some(existing => {
                                            for (let er = 0; er < existing.matrix.length; er++) {
                                                for (let ec = 0; ec < existing.matrix[er].length; ec++) {
                                                    if (existing.matrix[er][ec]) {
                                                        if (existing.x + ec === wx && existing.y + er === wy) {
                                                            return true;
                                                        }
                                                    }
                                                }
                                            }
                                            return false;
                                        })) {
                                            canPlace = false;
                                            break;
                                        }
                                    }
                                }
                                if (!canPlace) break;
                            }
                            if (!canPlace) break;
                        }
                        
                        if (canPlace) {
                            offsetX = tryX;
                            offsetY = tryY;
                            placed = true;
                        }
                    }
                }
                
                if (!placed) {
                    showNotification('No space to copy design!', true);
                    return;
                }
                
                saveHistory();
                design.blocks.forEach(block => {
                    State.placedBlocks.push({
                        x: block.x + offsetX,
                        y: block.y + offsetY,
                        color: block.color,
                        matrix: block.matrix.map(row => [...row])
                    });
                });
                
                renderCanvas();
                showNotification(`Design copied to canvas!`);
                AudioSys.play('place');
            }

            // Show public gallery
            async function showPublicGallery() {
                if (!State.user) {
                    showNotification('Please login first', true);
                    return;
                }

                let modal = document.getElementById('public-gallery-modal');
                let container = document.getElementById('public-gallery-container');
                
                container.innerHTML = '<p style="color:cyan; text-align:center;">Loading designs...</p>';
                modal.classList.add('active');
                
                await refreshGalleryTab('public');
            }

            async function refreshGalleryTab(tab) {
                let container = document.getElementById('public-gallery-container');
                let designs = [];
                
                container.innerHTML = '<p style="color:cyan; text-align:center;">Loading...</p>';
                
                try {
                    switch(tab) {
                        case 'public':
                            designs = await loadPublicDesigns();
                            break;
                        case 'private':
                            designs = await loadUserDesigns('private');
                            break;
                        case 'all':
                            designs = await loadUserDesigns();
                            break;
                    }
                } catch (error) {
                    console.error('Refresh error:', error);
                    container.innerHTML = '<p style="color:red; text-align:center;">Error loading designs</p>';
                    return;
                }
                
                let totalBlocks = designs.reduce((acc, d) => acc + (d.blockCount || 0), 0);
                document.getElementById('gallery-total-blocks').innerText = totalBlocks;
                document.getElementById('gallery-total-designs').innerText = designs.length;
                
                container.innerHTML = '';
                
                if (designs.length === 0) {
                    container.innerHTML = '<p style="color:gray; text-align:center; padding:20px;">No designs found. Be the first to create one!</p>';
                    return;
                }
                
                designs.forEach(design => {
                    let card = document.createElement('div');
                    card.className = 'gallery-item';
                    
                    let privacyBadge = document.createElement('div');
                    privacyBadge.className = `gallery-privacy ${design.privacy === 'public' ? 'privacy-public' : 'privacy-private'}`;
                    privacyBadge.textContent = design.privacy === 'public' ? 'üåç PUBLIC' : 'üîí PRIVATE';
                    
                    let thumbImg = document.createElement('img');
                    thumbImg.src = design.thumbnail;
                    thumbImg.style.width = '100%';
                    thumbImg.style.height = 'auto';
                    thumbImg.style.imageRendering = 'pixelated';
                    
                    let stats = document.createElement('div');
                    stats.className = 'gallery-stats';
                    let date = design.createdAt ? new Date(design.createdAt.toDate()).toLocaleDateString() : 'Recent';
                    stats.innerHTML = `
                        <span class="gallery-username">${design.username}</span>
                        <div class="gallery-name">${design.name || 'Unnamed'}</div>
                        ${design.description ? `<span style="color:#aaa;">${design.description.substring(0,30)}${design.description.length>30?'...':''}</span>` : ''}
                        <span>${design.blockCount} blocks</span>
                        <span>üìÖ ${date}</span>
                    `;
                    
                    let copyBadge = document.createElement('div');
                    copyBadge.className = 'copy-badge';
                    copyBadge.textContent = 'üìã COPY';
                    
                    card.appendChild(privacyBadge);
                    card.appendChild(thumbImg);
                    card.appendChild(stats);
                    card.appendChild(copyBadge);
                    
                    card.addEventListener('click', (e) => {
                        if (confirm(`Load design "${design.name}"? Current design will be replaced.`)) {
                            loadDesign(design);
                            document.getElementById('public-gallery-modal').classList.remove('active');
                        }
                    });
                    
                    card.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        copyDesignToCanvas(design);
                    });
                    
                    container.appendChild(card);
                });
            }

            function switchGalleryTab(tab) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.getElementById(`tab-${tab}`).classList.add('active');
                refreshGalleryTab(tab);
            }

            function hidePublicGallery() {
                document.getElementById('public-gallery-modal').classList.remove('active');
            }

            // Local Storage Functions (Backup)
            function saveDesignToLocal(designName, type = 'user') {
                try {
                    let tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 140;
                    tempCanvas.height = 80;
                    let tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#0a0a1f';
                    tempCtx.fillRect(0, 0, 140, 80);
                    
                    State.placedBlocks.forEach(block => {
                        block.matrix.forEach((row, ri) => {
                            row.forEach((cell, ci) => {
                                if (cell) {
                                    tempCtx.fillStyle = block.color;
                                    tempCtx.fillRect(block.x * 2 + ci * 2, block.y * 2 + ri * 2, 2, 2);
                                }
                            });
                        });
                    });
                    
                    let thumbnailUrl = tempCanvas.toDataURL('image/png');
                    
                    let design = {
                        id: Date.now(),
                        name: designName,
                        username: State.user ? State.user.username : 'Guest',
                        blockCount: State.placedBlocks.length,
                        created: new Date().toISOString(),
                        blocks: State.placedBlocks.map(block => ({
                            x: block.x,
                            y: block.y,
                            color: block.color,
                            matrix: block.matrix.map(row => [...row])
                        })),
                        thumbnail: thumbnailUrl
                    };
                    
                    let designs = JSON.parse(localStorage.getItem('tetris_designs') || '[]');
                    designs.unshift(design);
                    if (designs.length > 20) designs.pop();
                    localStorage.setItem('tetris_designs', JSON.stringify(designs));
                    
                    return true;
                } catch(e) {
                    console.warn('Local save failed:', e);
                    return false;
                }
            }
            
            function showLocalDesigns() {
                if (!State.user) {
                    showNotification('Please login first', true);
                    return;
                }
                
                let modal = document.getElementById('profile-modal');
                let container = document.getElementById('local-gallery-container');
                
                let designs = JSON.parse(localStorage.getItem('tetris_designs') || '[]');
                let userDesigns = designs.filter(d => d.username === State.user.username);
                
                document.getElementById('local-designs-count').innerText = userDesigns.length;
                
                container.innerHTML = '';
                
                if (userDesigns.length === 0) {
                    container.innerHTML = '<p style="color:gray; text-align:center; padding:20px;">No local backups yet.</p>';
                } else {
                    userDesigns.forEach(design => {
                        let card = document.createElement('div');
                        card.className = 'gallery-item';
                        
                        let thumbImg = document.createElement('img');
                        thumbImg.src = design.thumbnail;
                        thumbImg.style.width = '100%';
                        thumbImg.style.imageRendering = 'pixelated';
                        
                        let stats = document.createElement('div');
                        stats.className = 'gallery-stats';
                        let date = new Date(design.created).toLocaleDateString();
                        stats.innerHTML = `
                            <div class="gallery-name">${design.name || 'Unnamed'}</div>
                            <span>${design.blockCount} blocks</span>
                            <span>üìÖ ${date}</span>
                        `;
                        
                        card.appendChild(thumbImg);
                        card.appendChild(stats);
                        
                        card.onclick = () => {
                            if (confirm('Load this local backup? Current design will be replaced.')) {
                                loadDesign(design);
                                modal.classList.remove('active');
                            }
                        };
                        
                        container.appendChild(card);
                    });
                }
                
                modal.classList.add('active');
            }
            
            function hideProfileModal() {
                document.getElementById('profile-modal').classList.remove('active');
            }

            // Save modal functions
            function showSaveModal() {
                if (State.placedBlocks.length === 0) {
                    showNotification('No blocks to save!', true);
                    return;
                }
                document.getElementById('save-design-modal').classList.add('active');
                document.getElementById('design-name').value = '';
                document.getElementById('design-description').value = '';
                setDesignPrivacy('public');
            }

            function hideSaveModal() {
                document.getElementById('save-design-modal').classList.remove('active');
            }

            async function confirmSaveDesign() {
                let name = document.getElementById('design-name').value.trim();
                if (!name) {
                    showNotification('Please enter a design name!', true);
                    return;
                }
                
                let description = document.getElementById('design-description').value.trim();
                
                let success = await saveDesignToFirebase(name, description);
                if (success) {
                    hideSaveModal();
                }
            }

            // Tetris Game Functions
            function showTetrisGame() {
                if (!State.user) {
                    showNotification('Please login first', true);
                    return;
                }
                document.getElementById('tetris-game-modal').classList.add('active');
                initTetrisGame();
            }

            function hideTetrisGame() {
                document.getElementById('tetris-game-modal').classList.remove('active');
                if (TetrisGame.gameInterval) {
                    clearInterval(TetrisGame.gameInterval);
                    TetrisGame.gameInterval = null;
                }
                TetrisAudio.stopMusic();
                hideTetrisGameOverlay();
            }

            function showTetrisGameOverlay() {
                document.getElementById('final-score-value').textContent = TetrisGame.score;
                document.getElementById('final-lines-value').textContent = TetrisGame.lines;
                document.getElementById('game-overlay').classList.add('active');
            }

            function hideTetrisGameOverlay() {
                document.getElementById('game-overlay').classList.remove('active');
            }

            function restartTetrisGame() {
                hideTetrisGameOverlay();
                initTetrisGame();
            }

            function initTetrisGame() {
                TetrisGame.canvas = document.getElementById('game-canvas');
                TetrisGame.ctx = TetrisGame.canvas.getContext('2d');
                TetrisGame.nextCanvas = document.getElementById('next-canvas');
                TetrisGame.nextCtx = TetrisGame.nextCanvas.getContext('2d');
                
                // Reset grid
                TetrisGame.grid = Array(20).fill().map(() => Array(10).fill(0));
                TetrisGame.score = 0;
                TetrisGame.lines = 0;
                TetrisGame.level = 1;
                TetrisGame.gameOver = false;
                TetrisGame.paused = false;
                
                updateGameScore();
                hideTetrisGameOverlay();
                
                // Create first pieces
                TetrisGame.nextPiece = getRandomTetromino();
                spawnNewPiece();
                
                // Start game loop
                if (TetrisGame.gameInterval) {
                    clearInterval(TetrisGame.gameInterval);
                }
                TetrisGame.gameInterval = setInterval(gameTick, 500 / TetrisGame.level);
                
                // Start music
                if (document.getElementById('game-music-toggle').checked) {
                    TetrisAudio.playMusic();
                }
                
                // Set up keyboard controls
                setupTetrisControls();
            }

            function getRandomTetromino() {
                const index = Math.floor(Math.random() * TetrisGame.tetrominos.length);
                return {
                    matrix: TetrisGame.tetrominos[index].matrix.map(row => [...row]),
                    color: TetrisGame.tetrominos[index].color
                };
            }

            function spawnNewPiece() {
                if (TetrisGame.gameOver) return;
                
                TetrisGame.piece = TetrisGame.nextPiece;
                TetrisGame.nextPiece = getRandomTetromino();
                
                TetrisGame.piece.x = Math.floor((10 - TetrisGame.piece.matrix[0].length) / 2);
                TetrisGame.piece.y = 0;
                
                // Check for game over
                if (collision()) {
                    TetrisGame.gameOver = true;
                    TetrisAudio.playEffect('gameover');
                    if (TetrisGame.gameInterval) {
                        clearInterval(TetrisGame.gameInterval);
                        TetrisGame.gameInterval = null;
                    }
                    showTetrisGameOverlay();
                    return;
                }
                
                drawGame();
                drawNextPiece();
            }

            function collision() {
                if (!TetrisGame.piece) return false;
                
                for (let r = 0; r < TetrisGame.piece.matrix.length; r++) {
                    for (let c = 0; c < TetrisGame.piece.matrix[r].length; c++) {
                        if (TetrisGame.piece.matrix[r][c]) {
                            let newX = TetrisGame.piece.x + c;
                            let newY = TetrisGame.piece.y + r;
                            
                            if (newX < 0 || newX >= 10 || newY >= 20) {
                                return true;
                            }
                            
                            if (newY >= 0 && TetrisGame.grid[newY] && TetrisGame.grid[newY][newX] !== 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function mergePiece() {
                if (!TetrisGame.piece) return;
                
                for (let r = 0; r < TetrisGame.piece.matrix.length; r++) {
                    for (let c = 0; c < TetrisGame.piece.matrix[r].length; c++) {
                        if (TetrisGame.piece.matrix[r][c]) {
                            let y = TetrisGame.piece.y + r;
                            let x = TetrisGame.piece.x + c;
                            if (y >= 0 && y < 20 && x >= 0 && x < 10) {
                                TetrisGame.grid[y][x] = TetrisGame.piece.color;
                            }
                        }
                    }
                }
                
                clearLines();
                spawnNewPiece();
                drawGame();
            }

            function clearLines() {
                let linesCleared = 0;
                
                for (let y = 19; y >= 0; y--) {
                    if (TetrisGame.grid[y].every(cell => cell !== 0)) {
                        // Remove line
                        TetrisGame.grid.splice(y, 1);
                        TetrisGame.grid.unshift(Array(10).fill(0));
                        linesCleared++;
                        y++; // Check the same row again
                    }
                }
                
                if (linesCleared > 0) {
                    TetrisGame.lines += linesCleared;
                    TetrisGame.score += linesCleared * 100 * TetrisGame.level;
                    TetrisGame.level = 1 + Math.floor(TetrisGame.lines / 10);
                    
                    updateGameScore();
                    TetrisAudio.playEffect('line');
                    
                    // Update game speed
                    if (TetrisGame.gameInterval) {
                        clearInterval(TetrisGame.gameInterval);
                        TetrisGame.gameInterval = setInterval(gameTick, 500 / Math.min(TetrisGame.level, 10));
                    }
                }
            }

            function updateGameScore() {
                document.getElementById('game-score').textContent = TetrisGame.score;
                document.getElementById('game-lines').textContent = TetrisGame.lines;
                document.getElementById('game-level').textContent = TetrisGame.level;
            }

            function gameTick() {
                if (TetrisGame.paused || TetrisGame.gameOver) return;
                
                if (TetrisGame.piece) {
                    TetrisGame.piece.y++;
                    if (collision()) {
                        TetrisGame.piece.y--;
                        mergePiece();
                        TetrisAudio.playEffect('drop');
                    }
                    drawGame();
                }
            }

            function movePiece(dx, dy) {
                if (!TetrisGame.piece || TetrisGame.paused || TetrisGame.gameOver) return;
                
                TetrisGame.piece.x += dx;
                TetrisGame.piece.y += dy;
                
                if (collision()) {
                    TetrisGame.piece.x -= dx;
                    TetrisGame.piece.y -= dy;
                    
                    if (dy === 1) { // Moving down caused collision
                        mergePiece();
                        TetrisAudio.playEffect('drop');
                    }
                } else {
                    if (dx !== 0) TetrisAudio.playEffect('move');
                    drawGame();
                }
            }

            function rotatePiece() {
                if (!TetrisGame.piece || TetrisGame.paused || TetrisGame.gameOver) return;
                
                const matrix = TetrisGame.piece.matrix;
                const rotated = matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
                
                const previousMatrix = TetrisGame.piece.matrix;
                TetrisGame.piece.matrix = rotated;
                
                if (collision()) {
                    TetrisGame.piece.matrix = previousMatrix;
                } else {
                    TetrisAudio.playEffect('rotate');
                    drawGame();
                }
            }

            function hardDrop() {
                if (!TetrisGame.piece || TetrisGame.paused || TetrisGame.gameOver) return;
                
                while (!collision()) {
                    TetrisGame.piece.y++;
                }
                TetrisGame.piece.y--;
                mergePiece();
                TetrisAudio.playEffect('drop');
                drawGame();
            }

            function drawGame() {
                if (!TetrisGame.ctx) return;
                
                const ctx = TetrisGame.ctx;
                ctx.clearRect(0, 0, 300, 600);
                
                // Draw grid background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 300, 600);
                
                // Draw grid
                for (let y = 0; y < 20; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (TetrisGame.grid[y][x] !== 0) {
                            ctx.fillStyle = TetrisGame.grid[y][x];
                            ctx.fillRect(x * 30, y * 30, 28, 28);
                            
                            // Add highlight
                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.fillRect(x * 30, y * 30, 28, 4);
                            ctx.fillRect(x * 30, y * 30, 4, 28);
                        }
                    }
                }
                
                // Draw current piece
                if (TetrisGame.piece && !TetrisGame.gameOver) {
                    for (let r = 0; r < TetrisGame.piece.matrix.length; r++) {
                        for (let c = 0; c < TetrisGame.piece.matrix[r].length; c++) {
                            if (TetrisGame.piece.matrix[r][c]) {
                                let x = (TetrisGame.piece.x + c) * 30;
                                let y = (TetrisGame.piece.y + r) * 30;
                                ctx.fillStyle = TetrisGame.piece.color;
                                ctx.fillRect(x, y, 28, 28);
                                
                                // Add highlight
                                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                                ctx.fillRect(x, y, 28, 4);
                                ctx.fillRect(x, y, 4, 28);
                            }
                        }
                    }
                }
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(0,240,240,0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 30, 0);
                    ctx.lineTo(i * 30, 600);
                    ctx.strokeStyle = 'rgba(0,240,240,0.1)';
                    ctx.stroke();
                }
                for (let i = 0; i <= 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * 30);
                    ctx.lineTo(300, i * 30);
                    ctx.strokeStyle = 'rgba(0,240,240,0.1)';
                    ctx.stroke();
                }
            }

            function drawNextPiece() {
                if (!TetrisGame.nextCtx) return;
                
                const ctx = TetrisGame.nextCtx;
                ctx.clearRect(0, 0, 120, 120);
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 120, 120);
                
                if (TetrisGame.nextPiece) {
                    const matrix = TetrisGame.nextPiece.matrix;
                    const color = TetrisGame.nextPiece.color;
                    
                    const offsetX = (120 - (matrix[0].length * 30)) / 2;
                    const offsetY = (120 - (matrix.length * 30)) / 2;
                    
                    for (let r = 0; r < matrix.length; r++) {
                        for (let c = 0; c < matrix[r].length; c++) {
                            if (matrix[r][c]) {
                                let x = offsetX + c * 30;
                                let y = offsetY + r * 30;
                                ctx.fillStyle = color;
                                ctx.fillRect(x, y, 28, 28);
                                
                                // Add highlight
                                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                                ctx.fillRect(x, y, 28, 4);
                                ctx.fillRect(x, y, 4, 28);
                            }
                        }
                    }
                }
            }

            function setupTetrisControls() {
                document.removeEventListener('keydown', tetrisKeyHandler);
                document.addEventListener('keydown', tetrisKeyHandler);
            }

            function tetrisKeyHandler(e) {
                if (!document.getElementById('tetris-game-modal').classList.contains('active')) return;
                if (TetrisGame.gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        movePiece(0, 1);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        rotatePiece();
                        break;
                    case ' ':
                        e.preventDefault();
                        hardDrop();
                        break;
                    case 'p':
                    case 'P':
                        e.preventDefault();
                        pauseTetrisGame();
                        break;
                }
            }

            function startTetrisGame() {
                initTetrisGame();
            }

            function pauseTetrisGame() {
                if (TetrisGame.gameOver) return;
                TetrisGame.paused = !TetrisGame.paused;
                showNotification(TetrisGame.paused ? 'Game Paused' : 'Game Resumed');
            }

            window.onload = function() {
                for (let i=0; i<10; i++) {
                    let block = document.createElement('div');
                    block.className='floating-block';
                    block.style.left=Math.random()*100+'%';
                    block.style.animationDelay=Math.random()*20+'s';
                    block.style.background=`var(--tetris-${['cyan','blue','orange','yellow','green','purple','red'][Math.floor(Math.random()*7)]})`;
                    document.getElementById('floating-blocks').appendChild(block);
                }
                setTimeout(()=>{ document.getElementById('loading-screen').style.opacity='0'; setTimeout(()=>document.getElementById('loading-screen').style.display='none',500); },2000);

                State.canvas = document.getElementById('art-canvas');
                State.ctx = State.canvas.getContext('2d');
                State.previewCanvas = document.getElementById('block-preview');
                State.previewCtx = State.previewCanvas.getContext('2d');
                State.canvas.width = CONFIG.GRID_W * CONFIG.TILE_SIZE;
                State.canvas.height = CONFIG.GRID_H * CONFIG.TILE_SIZE;

                initShapeSelector();
                initColorPicker();
                setupEventListeners();
                auth.onAuthStateChanged(user => { if (user) loadUserData(user); });

                document.getElementById('scale-slider').addEventListener('input', (e) => {
                    State.scale = parseFloat(e.target.value);
                    document.getElementById('scale-value').textContent = Math.round(State.scale*100)+'%';
                    applyCanvasScale();
                });
                document.getElementById('opacity-slider').addEventListener('input', (e) => {
                    State.opacity = parseFloat(e.target.value);
                    document.getElementById('opacity-value').textContent = Math.round(State.opacity*100)+'%';
                });
                document.getElementById('sound-toggle').addEventListener('change', (e) => AudioSys.toggle(e.target.checked));
                document.getElementById('custom-color').addEventListener('input', (e) => document.getElementById('custom-hex').value = e.target.value);
                document.getElementById('custom-hex').addEventListener('input', (e) => { if (/^#[0-9A-F]{6}$/i.test(e.target.value)) document.getElementById('custom-color').value = e.target.value; });
                
                // Tetris game music toggle
                document.getElementById('game-music-toggle').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        TetrisAudio.playMusic();
                    } else {
                        TetrisAudio.stopMusic();
                    }
                });
                
                renderCanvas();
                
                let savedBg = localStorage.getItem('tetris_current_background');
                if (savedBg) {
                    document.body.style.backgroundImage = `url(${savedBg})`;
                    document.body.style.backgroundSize = 'cover';
                    document.body.style.backgroundPosition = 'center';
                    document.body.style.backgroundRepeat = 'no-repeat';
                }
            };

            function applyCanvasScale() {
                let scale = Math.min(State.scale, 1.8);
                State.canvas.style.width = (State.canvas.width * scale) + 'px';
                State.canvas.style.height = (State.canvas.height * scale) + 'px';
            }

            function setBlockType(type) {
                State.blockType = type;
                document.querySelectorAll('.block-type-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                renderCanvas();
            }

            function applyCustomColor() {
                State.currentColor = document.getElementById('custom-color').value;
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
                AudioSys.play('rotate');
            }

            function previewBackground() {
                if (State.placedBlocks.length===0) { showNotification('No blocks to preview!',true); return; }
                let previewCanvas = document.getElementById('bg-preview-canvas');
                previewCanvas.width = State.canvas.width; previewCanvas.height = State.canvas.height;
                let ctx = previewCanvas.getContext('2d');
                ctx.fillStyle = '#0a0a1f'; ctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
                State.placedBlocks.forEach(block => drawBlock(ctx, block.x, block.y, block.matrix, block.color));
                document.getElementById('bg-preview-modal').classList.add('active');
                AudioSys.play('rotate');
            }
            
            function hideBackgroundPreview() { document.getElementById('bg-preview-modal').classList.remove('active'); }
            
            function confirmApplyBackground() { 
                applyAsPageBackground(); 
                hideBackgroundPreview(); 
            }

            function setCanvasBackground() {
                if (State.placedBlocks.length===0) { showNotification('No blocks to set as canvas background',true); return; }
                let temp = document.createElement('canvas'); temp.width=State.canvas.width; temp.height=State.canvas.height;
                let tCtx = temp.getContext('2d'); tCtx.fillStyle='#0a0a1f'; tCtx.fillRect(0,0,temp.width,temp.height);
                State.placedBlocks.forEach(block=>drawBlock(tCtx,block.x,block.y,block.matrix,block.color));
                let dataUrl = temp.toDataURL('image/png');
                document.getElementById('canvas-wrapper').style.backgroundImage = `url(${dataUrl})`;
                document.getElementById('canvas-wrapper').style.backgroundSize = 'contain';
                document.getElementById('canvas-wrapper').style.backgroundRepeat = 'no-repeat';
                document.getElementById('canvas-wrapper').style.backgroundPosition = 'center';
                showNotification('Canvas background set!');
            }

            function initShapeSelector() {
                let container = document.getElementById('shape-selector');
                Object.keys(CONFIG.SHAPES).forEach(key => {
                    let btn = document.createElement('div');
                    btn.className = 'shape-btn' + (key==='T'?' active':'');
                    btn.textContent = key;
                    btn.onclick = () => selectShape(key, btn);
                    container.appendChild(btn);
                });
            }
            
            function initColorPicker() {
                let container = document.getElementById('color-picker');
                CONFIG.PALETTE.forEach((color,index) => {
                    let btn = document.createElement('div');
                    btn.className = 'color-btn' + (index===5?' active':'');
                    btn.style.background = color;
                    btn.onclick = () => selectColor(color, btn);
                    container.appendChild(btn);
                });
            }
            
            function selectShape(key, btn) {
                document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                State.currentShape = key;
                State.currentMatrix = CONFIG.SHAPES[key].matrix;
                State.currentColor = CONFIG.SHAPES[key].color;
                let colorBtns = document.querySelectorAll('.color-btn');
                colorBtns.forEach(b=>b.classList.remove('active'));
                let colorIndex = CONFIG.PALETTE.findIndex(c=>c===CONFIG.SHAPES[key].color);
                if (colorIndex!==-1) colorBtns[colorIndex].classList.add('active');
                AudioSys.play('rotate');
            }
            
            function selectColor(color, btn) {
                document.querySelectorAll('.color-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                State.currentColor = color;
                document.getElementById('custom-color').value = color;
                document.getElementById('custom-hex').value = color;
            }

            function setupEventListeners() {
                let canvas = State.canvas;
                canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    let rect = canvas.getBoundingClientRect();
                    let scale = State.scale;
                    let x = Math.floor((e.clientX - rect.left) / (CONFIG.TILE_SIZE * scale));
                    let y = Math.floor((e.clientY - rect.top) / (CONFIG.TILE_SIZE * scale));
                    if (x>=0 && y>=0 && x<CONFIG.GRID_W && y<CONFIG.GRID_H) {
                        if (e.button === 0) placeBlock(x, y);
                        else if (e.button === 2) deleteBlock(x, y);
                    }
                });
                canvas.addEventListener('contextmenu', e=>e.preventDefault());
                canvas.addEventListener('wheel', e=>{ e.preventDefault(); rotateShape(); });
                document.addEventListener('keydown', e=>{
                    if (!document.getElementById('login-screen').classList.contains('hidden')) return;
                    if (e.key==='r'||e.key==='R') rotateShape();
                    else if (e.ctrlKey && e.key==='z') { e.preventDefault(); undoAction(); }
                });
                document.addEventListener('mousemove', e=>{
                    if (document.getElementById('login-screen').classList.contains('hidden') && document.getElementById('app-container').classList.contains('visible'))
                        updatePreview(e);
                });
                document.getElementById('canvas-wrapper').addEventListener('mouseleave', ()=> State.previewCanvas.style.display='none');
            }

            function renderCanvas() {
                let ctx = State.ctx;
                ctx.clearRect(0,0,State.canvas.width,State.canvas.height);
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(0,240,240,0.15)';
                ctx.lineWidth = 1;
                for (let x=0;x<=CONFIG.GRID_W;x++) {
                    ctx.beginPath();
                    ctx.moveTo(x*CONFIG.TILE_SIZE,0);
                    ctx.lineTo(x*CONFIG.TILE_SIZE,State.canvas.height);
                    ctx.strokeStyle = x%4===0 ? 'rgba(240,240,0,0.2)' : 'rgba(0,240,240,0.1)';
                    ctx.stroke();
                }
                for (let y=0;y<=CONFIG.GRID_H;y++) {
                    ctx.beginPath();
                    ctx.moveTo(0,y*CONFIG.TILE_SIZE);
                    ctx.lineTo(State.canvas.width,y*CONFIG.TILE_SIZE);
                    ctx.strokeStyle = y%4===0 ? 'rgba(240,240,0,0.2)' : 'rgba(0,240,240,0.1)';
                    ctx.stroke();
                }
                
                State.placedBlocks.forEach(block => drawBlock(ctx, block.x, block.y, block.matrix, block.color));
                document.getElementById('block-count').textContent = State.placedBlocks.length;
            }

            function drawBlock(ctx, gridX, gridY, matrix, color) {
                let size = CONFIG.TILE_SIZE;
                let x = gridX*size, y = gridY*size;
                let opacity = State.opacity;
                
                matrix.forEach((row,rowIndex)=> row.forEach((cell,colIndex)=>{
                    if (cell) {
                        let px = x+colIndex*size, py = y+rowIndex*size;
                        ctx.globalAlpha = opacity;
                        
                        if (State.blockType==='solid') { 
                            ctx.fillStyle = color;
                            ctx.fillRect(px+1, py+1, size-2, size-2); 
                            
                            // Add subtle highlight
                            ctx.fillStyle = 'rgba(255,255,255,0.2)';
                            ctx.fillRect(px+1, py+1, size-2, 3);
                            ctx.fillRect(px+1, py+1, 3, size-2);
                        }
                        else if (State.blockType==='outline') { 
                            ctx.strokeStyle = color; 
                            ctx.lineWidth = 3; 
                            ctx.strokeRect(px+2, py+2, size-4, size-4); 
                        }
                        else if (State.blockType==='glow') { 
                            ctx.shadowColor = color; 
                            ctx.shadowBlur = 15; 
                            ctx.fillStyle = color; 
                            ctx.fillRect(px+1, py+1, size-2, size-2); 
                            ctx.shadowBlur = 0; 
                        }
                        else if (State.blockType==='3d') {
                            ctx.fillStyle = color; 
                            ctx.fillRect(px+1, py+1, size-2, size-2);
                            ctx.fillStyle = 'rgba(255,255,255,0.3)'; 
                            ctx.fillRect(px+1, py+1, size-2, 4); 
                            ctx.fillRect(px+1, py+1, 4, size-2);
                            ctx.fillStyle = 'rgba(0,0,0,0.3)'; 
                            ctx.fillRect(px+1, py+size-5, size-2, 4); 
                            ctx.fillRect(px+size-5, py+1, 4, size-2);
                        }
                        ctx.globalAlpha = 1;
                    }
                }));
            }

            function updatePreview(e) {
                let preview = State.previewCanvas, ctx = State.previewCtx;
                let rows = State.currentMatrix.length, cols = State.currentMatrix[0].length;
                preview.width = cols*CONFIG.TILE_SIZE; preview.height = rows*CONFIG.TILE_SIZE;
                ctx.clearRect(0,0,preview.width,preview.height);
                
                State.currentMatrix.forEach((row,rowIndex)=> row.forEach((cell,colIndex)=>{
                    if (cell) {
                        let x = colIndex*CONFIG.TILE_SIZE, y = rowIndex*CONFIG.TILE_SIZE;
                        
                        ctx.fillStyle = State.currentColor;
                        ctx.globalAlpha=0.7;
                        if (State.blockType==='glow') ctx.shadowColor=State.currentColor, ctx.shadowBlur=10;
                        ctx.fillRect(x+1,y+1,CONFIG.TILE_SIZE-2,CONFIG.TILE_SIZE-2);
                        
                        // Add highlight to preview
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.fillRect(x+1, y+1, CONFIG.TILE_SIZE-2, 3);
                        ctx.fillRect(x+1, y+1, 3, CONFIG.TILE_SIZE-2);
                        
                        ctx.shadowBlur=0; 
                        ctx.globalAlpha=1;
                    }
                }));
                preview.style.display = 'block';
                preview.style.left = (e.clientX+20)+'px';
                preview.style.top = (e.clientY+20)+'px';
            }

            function placeBlock(x,y) {
                saveHistory();
                if (!canPlace(x,y,State.currentMatrix)) { AudioSys.play('error'); return; }
                
                State.placedBlocks.push({
                    x, 
                    y, 
                    matrix: JSON.parse(JSON.stringify(State.currentMatrix)), 
                    color: State.currentColor
                });
                AudioSys.play('place'); 
                renderCanvas();
            }
            
            function deleteBlock(x,y) {
                saveHistory();
                let index = State.placedBlocks.findIndex(block => {
                    let m=block.matrix, lx=x-block.x, ly=y-block.y;
                    return ly>=0 && ly<m.length && lx>=0 && lx<m[0].length && m[ly][lx];
                });
                if (index!==-1) { State.placedBlocks.splice(index,1); AudioSys.play('delete'); renderCanvas(); }
            }
            
            function canPlace(x,y,matrix) {
                for (let r=0; r<matrix.length; r++) for (let c=0; c<matrix[r].length; c++) if (matrix[r][c]) {
                    let wx=x+c, wy=y+r;
                    if (wx<0||wx>=CONFIG.GRID_W||wy<0||wy>=CONFIG.GRID_H) return false;
                    if (State.placedBlocks.some(block=> {
                        let lx=wx-block.x, ly=wy-block.y;
                        return ly>=0 && ly<block.matrix.length && lx>=0 && lx<block.matrix[0].length && block.matrix[ly][lx];
                    })) return false;
                }
                return true;
            }
            
            function rotateShape() {
                let matrix = State.currentMatrix;
                State.currentMatrix = matrix[0].map((_,idx)=> matrix.map(row=>row[idx]).reverse());
                AudioSys.play('rotate');
            }
            
            function saveHistory() { State.history.push(JSON.stringify(State.placedBlocks)); if (State.history.length>50) State.history.shift(); }
            
            function undoAction() { if (State.history.length>0) { State.placedBlocks=JSON.parse(State.history.pop()); renderCanvas(); AudioSys.play('rotate'); } }
            
            function clearCanvas() { if (State.placedBlocks.length===0) return; saveHistory(); State.placedBlocks=[]; AudioSys.play('delete'); renderCanvas(); showNotification('Canvas cleared!'); }

            function applyAsPageBackground() {
                if (State.placedBlocks.length === 0) {
                    showNotification('No blocks to set as background!', true);
                    return;
                }
                
                let temp = document.createElement('canvas'); 
                temp.width = State.canvas.width; 
                temp.height = State.canvas.height;
                let tCtx = temp.getContext('2d'); 
                tCtx.fillStyle = '#0a0a1f'; 
                tCtx.fillRect(0, 0, temp.width, temp.height);
                State.placedBlocks.forEach(block => drawBlock(tCtx, block.x, block.y, block.matrix, block.color));
                let dataUrl = temp.toDataURL('image/png');
                
                document.body.style.backgroundImage = `url(${dataUrl})`;
                document.body.style.backgroundSize = 'cover';
                document.body.style.backgroundPosition = 'center';
                document.body.style.backgroundRepeat = 'no-repeat';
                
                localStorage.setItem('tetris_current_background', dataUrl);
                
                AudioSys.play('place'); 
                showNotification('Page background applied!');
            }

            function downloadBackground() {
                let temp = document.createElement('canvas'); temp.width=State.canvas.width; temp.height=State.canvas.height;
                let tCtx = temp.getContext('2d'); tCtx.fillStyle='#0a0a1f'; tCtx.fillRect(0,0,temp.width,temp.height);
                State.placedBlocks.forEach(block=>drawBlock(tCtx,block.x,block.y,block.matrix,block.color));
                let link = document.createElement('a'); link.download = `tetris-art-${Date.now()}.png`; link.href = temp.toDataURL('image/png'); link.click();
                showNotification('Image downloaded!');
            }

            // AUTH
            function showRegisterModal() { document.getElementById('register-modal').classList.add('active'); }
            function hideRegisterModal() { document.getElementById('register-modal').classList.remove('active'); }
            
            function handleRegister() {
                let username = document.getElementById('reg-username').value.trim();
                let email = document.getElementById('reg-email').value.trim();
                let pwd = document.getElementById('reg-password').value;
                let conf = document.getElementById('reg-confirm').value;
                if (!username||!email||!pwd||!conf) { AudioSys.play('error'); showNotification('Fill all fields!',true); return; }
                if (pwd!==conf) { AudioSys.play('error'); showNotification('Passwords mismatch!',true); return; }
                if (pwd.length<6) { AudioSys.play('error'); showNotification('Min 6 chars',true); return; }
                auth.createUserWithEmailAndPassword(email,pwd).then(cred=>{
                    return db.collection('users').doc(cred.user.uid).set({ username, email, level:1, created:firebase.firestore.FieldValue.serverTimestamp() })
                    .then(()=>cred.user.updateProfile({displayName:username}));
                }).then(()=>{ AudioSys.play('login'); showNotification('Account created!'); hideRegisterModal(); document.getElementById('login-email').value=email; })
                .catch(err=>{ AudioSys.play('error'); showNotification(err.message,true); });
            }
            
            function handleLogin() {
                let email = document.getElementById('login-email').value.trim();
                let pwd = document.getElementById('login-password').value;
                if (!email||!pwd) { AudioSys.play('error'); showNotification('Fill fields',true); return; }
                auth.signInWithEmailAndPassword(email,pwd).then(cred=>loadUserData(cred.user)).catch(err=>{ AudioSys.play('error'); showNotification(err.message,true); });
            }
            
            function loadUserData(user) {
                return db.collection('users').doc(user.uid).get().then(doc=>{
                    if (doc.exists) {
                        State.user = { id:user.uid, username:doc.data().username, email:user.email, level:doc.data().level||1 };
                        localStorage.setItem('tetris_user', JSON.stringify(State.user));
                        AudioSys.play('login');
                        showApp();
                    }
                }).catch(err => {
                    console.error('Error loading user data:', err);
                    showNotification('Error loading user data', true);
                });
            }
            
            function showApp() {
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('app-container').classList.add('visible');
                document.getElementById('display-username').textContent = State.user.username;
                document.getElementById('user-avatar').textContent = State.user.username[0].toUpperCase();
                document.getElementById('user-level').textContent = State.user.level;
                applyCanvasScale();
            }
            
            function logout() {
                auth.signOut().then(()=>{
                    localStorage.removeItem('tetris_user');
                    State.user=null; State.placedBlocks=[]; State.history=[];
                    document.getElementById('app-container').classList.remove('visible');
                    document.getElementById('login-screen').classList.remove('hidden');
                    renderCanvas(); showNotification('Logged out');
                });
            }

            function showNotification(msg, isErr=false) {
                let n = document.getElementById('notification');
                n.textContent = msg; n.className = isErr ? 'error show' : 'show';
                setTimeout(()=> n.classList.remove('show'), 3000);
            }

            // Expose globals
            window.selectShape = selectShape; 
            window.selectColor = selectColor; 
            window.rotateShape = rotateShape;
            window.undoAction = undoAction; 
            window.clearCanvas = clearCanvas; 
            window.previewBackground = previewBackground;
            window.confirmApplyBackground = confirmApplyBackground; 
            window.hideBackgroundPreview = hideBackgroundPreview;
            window.logout = logout;
            window.handleLogin = handleLogin; 
            window.handleRegister = handleRegister; 
            window.showRegisterModal = showRegisterModal;
            window.hideRegisterModal = hideRegisterModal; 
            window.downloadBackground = downloadBackground;
            window.setBlockType = setBlockType; 
            window.applyCustomColor = applyCustomColor;
            window.setCanvasBackground = setCanvasBackground;
            window.saveDesignToLocal = saveDesignToLocal;
            window.showLocalDesigns = showLocalDesigns;
            window.hideProfileModal = hideProfileModal;
            window.showProfileModal = showLocalDesigns;
            window.showSaveModal = showSaveModal;
            window.hideSaveModal = hideSaveModal;
            window.confirmSaveDesign = confirmSaveDesign;
            window.setDesignPrivacy = setDesignPrivacy;
            window.showPublicGallery = showPublicGallery;
            window.hidePublicGallery = hidePublicGallery;
            window.switchGalleryTab = switchGalleryTab;
            window.copyDesignToCanvas = copyDesignToCanvas;
            window.showTetrisGame = showTetrisGame;
            window.hideTetrisGame = hideTetrisGame;
            window.restartTetrisGame = restartTetrisGame;
            window.startTetrisGame = startTetrisGame;
            window.pauseTetrisGame = pauseTetrisGame;
            window.hideTetrisGameOverlay = hideTetrisGameOverlay;
        })();
    </script>
</body>
</html>
